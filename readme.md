## colorlight-litex-rs

My adventure on trying to control a
- [Colorlight 5A-75E v8.0 board](https://www.colorlight-led.com/product/colorlight-5a-75e-led-display-receiving-card.html)
    - Featuring a [Lattice ECP5 FPGA](https://www.latticesemi.com/Products/FPGAandCPLD/ECP5)
        - Running a [RISC-V SoC](https://github.com/SpinalHDL/VexRiscv)
            - Built with [LiteX](https://github.com/enjoy-digital/litex/tree/master)
                - Running custom firmware written in Rust ðŸ¦€

Everything with open-source tools!

## Contents

- [colorlight-litex-rs](#colorlight-litex-rs)
- [Contents](#contents)
- [SoC](#soc)
  - [Dependencies](#dependencies)
  - [Build](#build)
  - [Flash](#flash)
- [Firmware](#firmware)
  - [Build](#build-1)
  - [Run / Simulate firmware](#run--simulate-firmware)
- [PAC (Peripheral Access Crate)](#pac-peripheral-access-crate)
- [References](#references)


## SoC

[`soc.py`](./soc.py) builds FPGA bitstream with LiteX containing a simple RISC-V SoC to run firmware.

### Dependencies
- [litex](https://github.com/enjoy-digital/litex?tab=readme-ov-file#quick-start-guide)
- [yosys](https://github.com/YosysHQ/yosys)
- [prjtrellis](https://github.com/YosysHQ/prjtrellis)
- [nextpnr-ecp5](https://github.com/YosysHQ/nextpnr?tab=readme-ov-file#nextpnr-ecp5)
- [openFPGALoader](https://github.com/trabucayre/openFPGALoader)

### Build

build bitstream and generate needed files with:

    python3 soc.py --build --cpu-type vexriscv --csr-svd "./litex-pac/5a-75e_6.0.svd"

notes:
- *`5a-75e_6.0.svd` will be overwritten and used later for the litex pac (peripheral access crate).*
- you can use `--memory-x "../litex-pac/memory.x"`, however, I encountered many issues with the provided memory file, so I created my own one around `regions.ld` (see [#firmware](#firmware)).

### Flash

flash fpga with:

    python3 soc.py --load --no-compile-software

## Firmware

Firmware is built after SoC is also built, because it will depend on the memory regions defined at `regions.ld` (generated by LiteX).

- [firmware/memory.x](./firmware/memory.x): defines memory regions and interrupt handlers
- [firmware/build.rs](./firmware/build.rs): when `memory.x` or `regions.ld` change, we need to rebuild and put the linker script somewhere the linker can find it (with [firmware/.cargo/config](./firmware/.cargo/config))

### Build
```sh
cd firmware
BUILD_DIR=../build/colorlight_5a_75e cargo build --release
```

### Run / Simulate firmware

When running `cargo run`, by default, cargo will try to upload the generated `.bin` via [firmware/.cargo/flash.sh](./firmware/.cargo/flash.sh). However, if you want to simulate, you can change `config.runner` to run [firmware/.cargo/sim.sh](./firmware/.cargo/sim.sh).

    DEVICE=/dev/ttyUSB0 cargo run

Make sure to adjust `DEVICE` to your needs, since firmware `.bin` is uploaded via UART.

## PAC (Peripheral Access Crate)

When building the SoC, LiteX generates the `svd` file for us. With this, we can use `svd2rust` to create our PAC in order to access and manipulate the system. The PAC will use its [`build.rs`](./litex-pac/build.rs) to do this automatically.

## References
- [Colorlight-5A-75E datasheet](https://www.colorlight-led.tech/wp-content/uploads/2021/10/Colorlight-5A-75E.pdf)
- [roby2014/risc-v-colorlight-5a-75e](https://github.com/roby2014/risc-v-colorlight-5a-75e): similar example, but flashing C firmware
- [pepijndevos blog post](http://pepijndevos.nl/2020/08/04/a-rust-hal-for-your-litex-fpga-soc.html): helped a lot in this journey
- [roby2014 blogpost #1](https://roby2014-me.vercel.app/programming-a-colorlight-5a-75e-board-ECP5-FPGA-with-open-source-tools/): JTAG pin mapping for flashing bitstream
- [roby2014 blogpost #2](https://roby2014-me.vercel.app/risc-v-colorlight-5a-75e/): UART pin mapping for flashing firmware